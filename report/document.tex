
\documentclass[12pt,a4paper]{article}

%% Language and font encodings
\usepackage[french, english]{babel}

\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{footnote}
\usepackage{pgfplots}
\usepackage{tikz}
\usepackage{multicol}
\usepackage{diagbox}
\usepackage{float}
\usepackage{lastpage}
\usepackage{array}
\usepackage{fancyhdr}
\usepackage[english]{fancyref}
\usepackage[UKenglish]{datetime}
\usepackage{pdfpages}
%\usepackage{todonotes}
\usepackage{placeins}
%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=1cm,marginparwidth=1.75cm]{geometry}
\pgfplotsset{width=10cm,compat=1.9}
\setlength{\columnsep}{0.3cm}
\pagestyle{fancy}
\cfoot{Page \thepage \hspace{1pt} of \pageref{LastPage}}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\definecolor{titlepagecolor}{cmyk}{0,0,0,0}
\definecolor{namecolor}{cmyk}{1,1,1,1}
\usepackage{subcaption}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=black]{hyperref}
\usepackage{wrapfig}
\usepackage{listings}
\renewcommand{\thefigure}{\arabic{section}.\arabic{figure}}
%\renewcommand{\thetable}{\arabic{section}.\arabic{figure}}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.99,0.99,0.99}

\lstdefinestyle{CStyle}{
	backgroundcolor=\color{backgroundColour},   
	commentstyle=\color{mGreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{mGray},
	stringstyle=\color{mPurple},
	basicstyle=\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2,
	language=C
}
\lstdefinestyle{Bashstyle}{
	backgroundcolor=\color{backgroundColour},   
	commentstyle=\color{mGreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{mGray},
	stringstyle=\color{mPurple},
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                                                 
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2,
	language=bash
}
\lstdefinestyle{PyStyle}{
	backgroundcolor=\color{backgroundColour},   
	commentstyle=\color{mGreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{mGray},
	stringstyle=\color{mPurple},
	basicstyle=\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2,
	language=Python
}
\lstset{
	basicstyle=\ttfamily,
	columns=fullflexible,
	showstringspaces=false,
	commentstyle=\color{gray}\upshape
}

\lstdefinelanguage{XML}
{
	morestring=[b]",
	morestring=[s]{>}{<},
	morecomment=[s]{<?}{?>},
	numberstyle=\tiny\color{mGray},       
	breaklines=true, 
	numbers=left,            
	numbersep=5pt,       
	identifierstyle=\color{mGreen},
	keywordstyle=\color{magenta},
	morekeywords={xmlns,version,type}% list your attributes here
}
%\usepackage{natbib}
\pagestyle{fancy}
\title{Development and study of ailerons vs. twisting wing}
\author{\large{Negretto Didier Chérubin, MT-MA-3}}
\makeindex

\begin{document}
	\date{\today}
\begin{titlepage}
\hspace{+2.8cm} %defines the geometry for the titlepage
\pagecolor{titlepagecolor}
\noindent
\includegraphics[width=8cm]{fig/EPFL_Logo_Digital_RGB_PROD.jpg}\\[-1em]
\color{black}
\hspace{+3.5cm}
\makebox[3pt][l]{\rule{8 cm}{1pt}}
\par
\noindent
\hspace{+4.5cm}
\textbf{\Large \textsf{Biorobotics laboratory}}\\
\vspace{0.5cm}
\hspace{-3.5cm}
	%\begin{figure}[H]
    %	\centering
		%\includegraphics[width=12 cm]{fig/frontpage_1.pdf}
		%\includegraphics[width=0.48\linewidth]{fig_pos/FS}
		%\raisebox{-5cm}{\reflectbox{\includegraphics[width=0.48\linewidth]{fig_pos/BS}}}
%					\includegraphics[width=0.49\linewidth]{fig_pos/BS}
%		\reflectbox{\includegraphics[width=0.49\linewidth]{fig_pos/BS}}
	%\end{figure}

\vfill


\hspace{+0.5cm}
{\huge \huge \textsf{MOUSE TREADMILL CONTROL}}

\vskip\baselineskip
\noindent
\hspace{+3.5cm}
{\textsf{\today}
\vskip\baselineskip
\noindent
\hspace{+3.5cm}
{\textsf{By \textbf{\Large{Didier Chérubin Negretto} }}}
\vskip\baselineskip
\noindent
\hspace{+3.5cm}
{\textsf{Professor: \large\textbf{Auke Ijspeert}}}
\vskip\baselineskip
\noindent
\hspace{+3.5cm}
{\textsf{Assistant 1:\textbf{Shravan Tata Ramalingasetty} }}
}
\end{titlepage}

\restoregeometry % restores the geometry
\nopagecolor% Use this to restore the color pages to white
\begin{center}
\chead{\textit{\textbf{Mouse treadmill control}}}
%\newpage
\textbf{\Large{Semester project description}}\\
\end{center}
\begin{multicols}{2}
[]

\paragraph{Objectives and preliminary considerations} 
\lfoot{\today}
\rfoot{Biorobotics laboratory}
The project consists of designing and manufacturing of a lightweight mechanism to improve roll authority at low angles of attack. After that the mechanism is tested and conclusions, with respect to the existing mechanism are drawn.
A drone with morphing wings was designed and manufactured in the months before this project. The drone has wings with artificial overlapping feathers at the wing tip, which are used for roll control. The roll rate obtained at low angles of attack is too low to grant the desired high manoeuvrability as shown by \cite{ref6} for a similar roll control strategy. In the first part of the project different methods are taken into account: ailerons, which are used in the aircraft industry and wing twisting, which is inspired by birds \cite{bird}. Those methods are simulated on XFLR5 (using VLM and 3D-Panels), after which wing twisting is chosen for implementation and testing. Wing twisting has many advantages compared to ailerons: higher roll moment \cite{real_plane} and higher lift to drag ratio \cite{ref3}. On the other hand this technique is less used in industry and leads to an increased weight of the drone. 
%\begin{figure}[H]
%	\includegraphics[width=0.8\linewidth]{fig_des/exp_setup.jpg}
%	\caption{Photo taken during the wind tunnel test, with a symmetric backward sweep configuration. }\label{fig:wind}
%\end{figure}
\paragraph{Mechanism design}
 A weight of less than 20 [$g$] is required as well as the interoperability with the pre-existing folding mechanism. Four different designs are taken into account (partial twisting, flexible components, cylindrical element and ball joints). In the end the design consisting of a lever actuated by a servo (ball joints) is chosen for implementation. This design is simple and can generate the required roll (roll control power over 2 [$\frac{\partial C_r}{\partial rad}$] for $\alpha \leq 8^\circ$) at low angles of attack, solving the initial problem. The folding angle $\phi$ is defined as the sum of the angles compared to normal sweep on the two sides. 
\paragraph{Testing and results}
\begin{figure}[H]
	\centering
	%\includegraphics[width=1.2\linewidth]{fig_des/fin_comp}
	%\includegraphics[width=\linewidth]{fig_sim/fin_comp}
	\caption{Roll coefficient as a function of the angle of attack for different values of twisting and folding angles. Schematics of folding configurations are added. }\label{fig:tw_vs_fold_bar}
\end{figure}
The third part consists of testing the drone in the wind tunnel at different angles of attack (from 0$^\circ$ to 28$^\circ$ with steps of 4$^\circ$), at three different twisting angles (0$^\circ$, 5$^\circ$ and 10$^\circ$), and with three possible wing shapes to take into account the effect of folding. Most of roll is generated with twisting at low angles of attack ($\alpha<8^\circ$), while at high angles folding has a greater impact (see figure \ref{fig:tw_vs_fold_bar}).
\paragraph{Roll control and cost}
Finally a roll control algorithm for folding and twisting wing drones is presented.  This is one of the most important accomplishments of this report since a study of different roll control methods on the same platform is, at the best of our knowledge, absent in literature. The cost of such a setup is discussed as well. This cost is very low, mainly due to the weight of the mechanism and to the energy consumption since the loss of aerodynamic performances during roll is small ($C_d$ +38,98\%), compared to the roll achieved ($C_r = 0.4519$ [ ]).

\end{multicols}

\clearpage
\lfoot{ }
\rfoot{ }
\chead{ }
%\begin{abstract}

%\end{abstract}

\pagestyle{plain}
\clearpage

\tableofcontents
\clearpage
\pagestyle{fancy}
\section{Introduction}\label{sec:intro}
In this section the main objectives and the state of the art for the project are presented as well as the overall structure of this report.
\subsection{Motivation}
\begin{wrapfigure}{L}{0.42\textwidth}
	\includegraphics[width=\linewidth]{fig/OleSetup.png}
	\caption{The experimental setup used in \cite{Ole}.}\label{fig:OleSetup}
	\vspace{-2 cm}
\end{wrapfigure}
The studies on mammal locomotion have driven more and more attention over the years, and especially experiments on mice, such as \cite{Ole}, have enhanced our understanding of the neuronal circuits that enable locomotion. The experimental setup in \cite{Ole}, on the other hand, is quite rudimental. As shown in \ref{fig:OleSetup} it only consist in a spiral maze made out cardboard. This setup comes with some advantages such as:
\begin{itemize}
	\item Low price
	\item Simple to implement and use
	\item Untrained mice can be employed
	\item Free moving mouse
\end{itemize}
As well as some disadvantages:
\begin{itemize}
	\item Impossibility to analyse the mouse gait
	\item The mouse movements can't be imposed
\end{itemize}
To asses these issues a new design is needed for conducting such experiments. The new platform needs to allow the control on the walking surface on which the mouse is standing in such a way that a specific speed profile can be imposed to the mouse. Moreover it must be possible to analyse the mouse gait using cameras. \\
For the new design inspiration is taken from some existing solutions on the market. 
\subsection{Requirements}
First the mechanical requirements are discussed and stated. Table \ref{tab:Requirements} summarizes them.
\begin{table}[H]
	\centering
	\begin{tabular}{l||c|r} 
		\textbf{Description}&\textbf{Value}  &\textbf{Unit}  \\ 
		\hline
		\hline 
		Dimensions of the moving surface & 0.5 & $[m^2]$ \\ 
		\hline 
		Course & $\infty$  & $[m]$  \\ 
		\hline 
		Maximum speed & 3 & $[\frac{m}{s}]$ \\ 
		\hline 
		Maximum acceleration & 2 & $[\frac{m}{s^2}]$  \\ 
		\hline 
		Position resolution & 0.01 & $[m]$  \\ 
		\hline 
		Speed resolution & 0.02  & $[\frac{m}{s}]$  \\ 
		\hline 
		Maximum weight & 0.1  & $[kg]$  \\  
		\hline 
		Mounting time for 1 person & 30 & $[min]$  \\
		\hline 
		Maximum weight of the mouse & 40  & $[g]$ \\
		\hline 
		Length of common experiment (distance, time) & (20, 600)  & ($[m]$,$[s]$)  \\
	\end{tabular} 
	\caption{Summary of the requirements for the mouse treadmill platform.}
	\label{tab:Requirements}
\end{table}
The functional requirements are listed as well:
\begin{itemize}
	\item \textbf{Closed-loop control} Once a 2D speed setpoint is chosen the speed of the surface needs to be measured and the motor control signal need to be adjusted automatically to reach the desired setpoint. 
	\item \textbf{Speed routines} The user can define a speed routine, which needs to be executed by the treadmill. The speed routine consist in a list of 2D speed setpoints and the time interval during which the machine should execute them.
	\item \textbf{User interface} The user can use a Graphical user interface (GUI) on a computer to be able to use the mouse treadmill. This interface informs the user if the sensors are correctly connected and initialized, and it should give a live update of the treadmill speed.
	\item \textbf{Data logging} The user can save the data sent by the treadmill during the experiment for future uses. 
	\item \textbf{Expandability of the system} The user can easily expand the system with other controllers to have other features, than the ones listed above.
\end{itemize}

\subsection{Structure of the report}
This report is structured as follows: an introduction is given in section \ref{sec:intro}, the system architecture and communication are explained in \ref{sec:archi}. Section \ref{sec:design}, describes the design decisions and the components choices made .Section \ref{sec:control} describes the control strategy and shows some preliminary responses.
Finally in section \ref{sec:conc} the conclusion of the project is given. The code, code documentation as well as the data-sheets of the components are annexed.

\section{System architecture} \label{sec:archi}
In this section the architecture of the system is explained and detailed.
One first overview of the system is given in figure \ref{fig:arch}.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{fig/archi.pdf}
	\caption{Architecture for mouse treadmill project}
	\label{fig:arch}
\end{figure}
The core of the system is the STM32L476RG, which can read from the sensors using the SPI interface and control the motors using the PWM. Moreover it can communicate with the computer and the GUI for data logging and to receive the inputs form the user. The communication with the computer uses the DMA capabilities of the microcontroller to free the processor from waiting for the communication to end before being able to take care of other tasks.

\section{Design choices}\label{sec:design}
In this section the design choices are explained and justified. First the choice of the board is analysed, then the sensors and finally the calculations for the motor dimensioning are shown.
\subsection{Board}
For the board choice different types are taken into account:
\begin{itemize}
	\item \textbf{Single board computer}: In this category the raspberry pi and the odroid are taken into consideration. These boards offer powerful computers, which can be running operating systems such as Linux or Windows, which makes them interesting. Unfortunately they can't provide any accurate timing,  which is needed for the motor control and PWM generation.
	\item \textbf{Evaluation boards}: In this category the STM32 nucleo boards as well as the arduino boards can be found. These boards allow proper timing of the signals and accurate PWM generation, but on the other hand a computer is needed for plotting and storing the data, which can't be done locally on the board due to memory restrictions and limited resources on the board.
\end{itemize}
Due to the constraints in the system the second category is consider for implementation, the STM32L476RG board is taken for the system. Table \ref{tab:board} summarizes the features of the board.
\begin{table}[H]
	\centering
	\begin{tabular}{l||c|r} 
		\textbf{Description}&\textbf{Value}  &\textbf{Unit}  \\ 
		\hline
		\hline 
		Architecture & ARM-Cortex 32-bit with FPU & $-$ \\ 
		\hline 
		Clock frequency & 80  & $[MHz]$  \\ 
		\hline 
		Flash memory & 1 & $[MB]$ \\ 
		\hline 
		RAM memory & 128 & $[KB]$  \\ 
		\hline 
		I2C interfaces & 3 & $-$  \\ 
		\hline 
		USART interfaces & 5  & $-$  \\ 
		\hline 
		SPI interfaces & 3  & $-$  \\  
		\hline 
		DMA controller & 14 & $-$  \\
		\hline
		Cost & 20.58 &$[CHF]$
	\end{tabular} 
	\caption{STM32L476RG main features.}
	\label{tab:board}
\end{table}
One of the most important feature of the board is the DMA, which enhances the performances of the CPU. The DMA is used for the UART communication with the computer. This technique frees the CPU from waiting for the UART communication to be finished, so that it can spend more time on other activities. This same solution can be, in principle, adopted for the SPI communication if a standard SPI is used. Unfortunately the timing diagrams for the sensors are not standard, thus some time needs to be "wasted" by the processor so that the sensors can keep up with the communication.
Other interesting features are: the big flash memory, the good RAM memory and the low cost. One drawback is that dynamic memory allocation is not possible in such an small system to prevent stack overflow and problems during run time. This is why the size of the speed routine is limited to a given number of points.
Finally the multiple serial interfaces allow the possibility to expand the system to a bigger one with more controllers involved.

\subsection{Communication}
\begin{wrapfigure}{R}{0.42\textwidth}
	\includegraphics[width=\linewidth]{fig/MAVLink_logo.png}
	\caption{MAVLink logo}\label{fig:MAVLink_logo}
\end{wrapfigure}
For the communication with the computer the UART protocol is chosen. This choice is almost mandatory since most boards are provided with an UART to USB interface and a mini-USB connector. The STM32L476RG is no exception to this rule.

Since the system needs to be expanded for future more complex experiments some thought is put in the choice of the messaging protocol to allow this key feature.
The best solution found is MAVLink. "MAVLink is a very lightweight messaging protocol for communicating with drones"\cite{mavlink}, one can say that the mouse treadmill is not meant to fly around, but this messaging protocol is flexible enough to be adapted to the mouse treadmill.
More precisely a dialect is described in \ref{app:mavlink}, and summarized in table \ref{tab:msg}. Thanks to the description file it is possible to generate libraries in different programming languages (C, Python, Java, ...) and if in the future a new message is required a additional definition can be added to the file and the libraries can be regenerated.

Despite the light weight MAVLink comes with some interesting features, such is high reliability (detects packets drops and corruption), high efficiency (only 14-bits of overhead), it can also allow up to 255 concurrent systems on the network.

\begin{table}[H]
	\centering
	\begin{tabular}{l||p{3cm}|l|l} 
		\textbf{Name} &\textbf{Description} &\textbf{Sender} &\textbf{Receiver}\\ 
		\hline
		\hline 
		HEARTBEAT &Verifies communication& STM32 & PC \\ 
		\hline 
		SPEED\_INFO &Measured speed  & STM32 & PC \\ 
		\hline 
		SPEED\_SETPOINT & Speed setpoint & PC & STM32 \\ 
		\hline 
		MODE\_SELECTION & Changes mode & PC & STM32  \\ 
		\hline 
		MOTOR\_SETPOINT & Up time of PWM duty cycle & STM32 & PC  \\ 
		\hline 
		POINT\_LOADED & Acknowledge for routine point loaded  & STM32 & PC  \\ 
		\hline 
		POINT & Information for one point of the routine  & PC & STM32  \\  
		\hline 
		ERROR & Error message & STM32 & PC  \\
		\hline
		RAW\_SENSOR & Raw sensor values & STM32 & PC \\
	\end{tabular} 
	\caption{List and description of the MAVLink messages.}
	\label{tab:msg}
\end{table}


\subsection{Sensor}
For sensing the speed of the wheel a contactless solution is chosen. To achieve this goal a optical gaming mouse sensor is taken. Nevertheless the sensor need to come mounted on a PCB with a simple interface to reduce the time needed to design and manufacture the machine.
Because of that the PMW3360 is chosen for the implentation.
The working principle of the sensor is quite simple. The sensor is equipped with a LED to light a given area and a camera. The camera takes picture of the moving surface with a frequency of up to 12000 $[fps]$. Using the integrated DSP module some features are extracted form the images and, by knowing the displacement of the features, it is possible to determine how much the surface has moved on the X and Y direction.
Some other useful information can be retrieved from the sensor such as :
\begin{itemize}
	\item \textbf{Lift status} This bit in the motion register gives information about the status of the sensor and especially if the sensor detects a surface or not. This information is used to determine if the read value is valid or not.
	\item \textbf{Surface quality (SQUAL)} This register gives an information about how many features are detected on the surface. This value is used to verify the quality of the measurement, which is considered valid only if the number of detected feature is above a given threshold.
	\item \textbf{SROM ID} This value is read after the power up of the sensor to verify that the SROM of the sensor is uploaded correctly using the SPI interface. If this value is not as expected it means that the sensor is not initialized correctly and thus might not work properly. 
\end{itemize}
The performances of the sensor are summarized on table \ref{tab:PMW3360}\footnote{$[cpi]$ stands for counts per inch.}. For more details refer to \ref{app:PMW3660}.
\begin{table}[H]
	\centering
	\begin{tabular}{l||c|r} 
		\textbf{Description}&\textbf{Value}  &\textbf{Unit}  \\ 
		\hline
		\hline 
		High speed detection & 6.3 & $[\frac{m}{s}]$ \\ 
		\hline 
		High acceleration detection & 490  & $[\frac{m}{s^2}]$  \\ 
		\hline 
		Default resolution & 5000 & $[cpi]$ \\ 
		\hline 
		Resolution error of & 1 & $[\%]$  \\ 
		\hline 
		4 wires SPI interface & 1 & $-$  \\ 
		\hline
		Cost & 29.99 &$[\$]$
	\end{tabular} 
	\caption{PMW3660 main features.}
	\label{tab:PMW3360}
\end{table}


\subsection{Motor}
To properly dimension the motors these assumptions are taken:
\begin{enumerate}
	\item $\eta = 1$ No losses in wheel-sphere coupling
	\item No slip of the wheel on the sphere
	\item Hollow sphere
	\item Flat disk
\end{enumerate}

The data given are:
\begin{itemize}
	\item $m_s$ mass of the sphere
	\item $r_s$ radius of the sphere
	\item $m_w$ mass of the wheel
	\item $r_w$ radius of the wheel
	\item $M_{max}$ maximum torque provided by the motor-gearbox 
	\item $\omega_{max}$ maximum angular speed of the motor-gearbox
	\item $J_m$ inertia of the rotor
\end{itemize}
It is therefore possible to estimate the maximum continuous  acceleration and speed of the sphere.
\section[User manual]{User manual for mouse treadmill software}
The software is well documented in the docs folder, nevertheless some important things are pointed out in this report so that the user can more easily install and start using the mouse treadmill. The installation guide for the PC software, a user manual for the GUI, a explanation on how to write a speed routine as well as a guide on how to expand the system with new messages is provided. Note that all the provided commands and instructions are tested for MAC, mavlink is available also for LINUX and WINDOWS, the user can adapt these command to be able to install and successfully use the software on his machine. 
\subsection{Installation of the PC software}
First python 3 needs to be installed, for that see \cite{py}. GIT needs to be install as well. Some other python packages needs to be installed, they can be obtained using PiP. The required ones are:\\
\begin{multicols}{3}[]
\begin{itemize}
	\item pyserial
	\item os
	\item sys
	\item numpy
	\item appjar
	\item tqdm
	\item json
	\item matplotlib
\end{itemize}
\end{multicols}

Make sure that pymavlink is not install. This is important since the dialect used is a standard one, but it is custom. Do not install pymavlink using PiP.\\

To install the software the sequent steps have to be accomplished:
\begin{enumerate}
	\item Clone the git repository of the project using 
	\begin{lstlisting}[style = Bashstyle]
		$ git clone https://github.com/DidierNegretto/3DMouseTreadmill.git
	\end{lstlisting}
	\item Move inside the repository
	\begin{lstlisting}[style = Bashstyle]
		$ cd 3DMouseTreadmill/
	\end{lstlisting}
	\item Make sure no previous version of pymavlink is installed
	\begin{lstlisting}[style = Bashstyle]
		$ pip uninstall pymavlink
	\end{lstlisting}
	\item Remove the mavlink directory
	\begin{lstlisting}[style = Bashstyle]
		$ rm -r -f mavlink/
	\end{lstlisting}
	\item Clone the mavlink repository
	\begin{lstlisting}[style = Bashstyle]
		$ git clone https://github.com/mavlink/mavlink.git
	\end{lstlisting}
	\item Update the submodule
	\begin{lstlisting}[style = Bashstyle]
		$ git submodule update --init --recursive
	\end{lstlisting}
	\item Copy mouse.xml file and the mouse.py files into mavlink/pymavlink/dialects/v20 
	\item Change directory to mavlink/
	\begin{lstlisting}[style = Bashstyle]
		$ cd mavlink
	\end{lstlisting}
	\item Export the path to the repository so that python will find all the code it needs to run
	\begin{lstlisting}[style = Bashstyle]
		$ export PYTHONPATH=`path_to_repository/3DMouseTreadmill/`
	\end{lstlisting}
	\item Change directory to pymavlink
	\begin{lstlisting}[style = Bashstyle]
		$ cd pymavlink
	\end{lstlisting}
	\item Setup everything using the setup.py provided
	\begin{lstlisting}[style = Bashstyle]
		$ python3 setup.py install --user
	\end{lstlisting}
	
\end{enumerate}
\subsection{How to use the GUI} 
\subsection{How to write a routine}
An example routine is provided in MouseTreadmillPC/python/routine.py. The routine is a python dictionary containing a list of durations, setpoint\_x and setpoint\_y. The two setpoints define the desired speed along x and y, while the duration is the time span during which the two setpoints are applied. One should notice that the system time is discrete and increased every millisecond, moreover one should take into account the settling time for the control and the maximum acceleration provided by the motors to do a proper discretization of the desired speed profile.\\
A duration of 0 means that the end of the routine is reached and the routine is started again at the first point defined. A maximum of 255 points can be defined, if more points are needed the id of the point have to be changed from type uint8\_t to uint16\_t to allow for IDs above 255. A memory limitation is still present, but for a number of points above 1'000.
\subsection{How to extend the system}
\todo{Say where to generate all the libraries !!!}

\section{Control} \label{sec:control}
In this section the main aspect of the control are discussed as well as some results.
For the closed-loop control a simple PI controller is used (see \ref{sec:controller}). This can be improved in future works to allow for faster and better performance control. The implementation of the controller is done in CodeSTM32/mouseDrive.c in the function void mouseDriver\_control\_idle(void). 

\subsection{Inputs/Outputs}
In this section the signal definitions are described.
The control diagram is shown in figure \ref{fig:ctrl_diag}. The signals are defined as follow:
\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{fig/ctrl_diag.pdf}
	\caption{Control diagram}\label{fig:ctrl_diag}
\end{figure}

\begin{itemize}
	\item 
	$X = \begin{bmatrix}
	v_x\\
	v_y
	\end{bmatrix}$
	: is the measured $v_x$ and $v_y$ speeds. This measure is done using the optical sensors, which means that the raw values are as defined in the datasheet of the sensors (see \ref{app:PMW3660}). In short words the sensor runs a navigation program, which does the correlation between two images as fast as possible and finds out of how many counts the two images are displaced in the $x$ and $y$ direction of the sensor, those values are then integrated up to when the motion burst is performed. Since two sensors are used, only one axis of each sensor is meaningful for the control (since the other one is always fixed). The information that can be retrieved from one sensor is the number of counts along one axis that the ball has done since the last read. This can then be translated in to meters by knowing the resolution of the sensor (which is given in counts per inch) and the relation between inches and meters. Furthermore the speed can be computed by keeping track of when the last measure is taken, and the actual time, thus knowing the $dt$ between two measures.
	\item	
	$E = \begin{bmatrix}
	e_x\\
	e_y
	\end{bmatrix}$: is the error id est the difference between the setpoint and the measured speed
	\item  
	$U = 
	\begin{bmatrix}
		u_x\\
		u_y
	\end{bmatrix}$: is the control signal, which is the up time of the duty cycle of the PWM signal controlling the X and Y directions. The parameters of this signal can be modified by using the PRESCALER\_PWM and COUNTER\_PERIOD\_PWM. This two values allow for defining the frequency and number of possible values of the PWM signal.
\end{itemize}
\subsection{Controller} \label{sec:controller}
In this section the internal structure of the controller is described.
The inputs in the controller are the errors on the speed setpoint in X and Y. The control signal is defined as in equation \ref{eq:U}.
\begin{equation}\label{eq:U}
U = 
\begin{bmatrix}
u_x\\
u_y
\end{bmatrix}
= K * 
\begin{bmatrix}
e_x\\
e_y
\end{bmatrix} + I *
\begin{bmatrix}
i_x\\
i_y
\end{bmatrix} 
\end{equation}
Where $K$ and $I$ are constant scalar values and $\begin{bmatrix}i_x\\i_y\end{bmatrix}$ is a vector containing the sum of the errors over all the past measures where the motor signal $U$ is not the maximum allowed. This condition is taken to avoid wind up and overshoot in the controller.\\
Moreover the control is done only if the measures taken are valid. Which means that the SQUAL measure is bigger than SQUAL\_THRESH, the sensors are not lifted, and the PRODUCT\_ID is equal 66.
If those conditions are met it means that the surface quality is good, the sensor "sees" correctly the surface and the communication is done correctly.
If the measures are not valid for more than MAX\_MISSING\_MEASURES the motors are stopped and the mode goes to STOP mode to avoid damage to the machine.
\subsection{Results}
In this section the results of the control are shown as well as the achieved performances in terms measures \ref{sec:measure_test} and control \ref{sec:control_test}.
\subsubsection{Measure test}\label{sec:measure_test}
In this section a simple experiment is described and the results are shown. The experiment consist in letting the ball spin in at constant speed in one direction and measure the speed using the sensors. By doing this it is possible to analyze the noise present in the sensor and characterize it.
\subsubsection{Control test}\label{sec:control_test}







\section{Conclusion} \label{sec:conc}



\clearpage
\lhead{ }
\begin{thebibliography}{100}
	
	\bibitem{Ole}Jared M. Cregg, Roberto Leiras, Alexia Montalant, Ian R. Wickersham, and Ole Kiehn, \textit{Brainstem Neurons that Command Left/Right Locomotor Asymmetries} 
	\bibitem{mavlink} MAVLink Developer Guide, \textit{https://mavlink.io/en/}
	\bibitem{py} Python website, \textit{https://www.python.org/downloads/}
	
	\bibitem{sar} Robin R. Murphy, Eric Steimle et al. \textit{Cooperative Use of Unmanned Sea Surface and Micro Aerial Vehicles at Hurricane Wilma},Journal of Field Robotics,2008
	\bibitem{eco}     Kenzo Nonami, Farid Kendoul, Satoshi Suzuki, Wei Wang, Daisuke Nakazawa,\textit{Autonomous Flying Robots}, Springer, 2010.
	\bibitem{roll} G. Sachs, \textit{What Can Be Learned from Unique Lateral-Directional Dynamics Properties of Birds for Mini-Aircraft}, Atmospheric Flight Mechanics Conference and Exhibit, 2007
	%\bibitem{ref1} Onur Bilgen, Kevin B. Kochersberger, and Daniel J. Inman, \textit{Novel, Bidirectional, Variable-Camber Airfoil via Macro-Fiber Composite Actuators}, Journal of aircraft Vol. 47, No. 1, January–February 2010.
	\bibitem{real_plane} R. Pecora, F. Amoroso, and L. Lecce, \textit{Effectiveness of Wing Twist Morphing in Roll Control}, Journal of aircraft Vol. 49, No. 6, November–December 2012
	\bibitem{ref3} Osgar John Ohanian III, Christopher Hickling, Brandon Stiltner, Etan D. Karni, \textit{Piezoelectric Morphing versus Servo-Actuated MAV Control Surfaces}, 53rd AIAA/ASME/ASCE/AHS/ASC Structures, Structural Dynamics and Materials Conference, 2012
	\bibitem{ref4} Helen M. Garcia , Mujahid Abdulrahim and Rick Lind, \textit{Roll control for a micro air vehicle using active wing morphing}, AIAA Guidance, Navigation, and Control Conference and Exhibit, 2003
	\bibitem{ref5} Mujahid Abdulrahim, Helen Garcia, and Rick Lind, \textit{Flight Characteristics of Shaping the Membrane Wing of a Micro Air Vehicle}, Journal of aircraft Vol. 42, No. 1, January–February 2005
	\bibitem{ref6} M. Di Luca, S. Mintchev, G. Heitz, F. Noca and D. Floreano, \textit{Bioinspired morphing wings for extended flight envelope and roll control of small drones}, Interface Focus 7, 2017
	\bibitem{urb_env} William E. Green and Paul Y. Oh, \textit{A Hybrid MAV for Ingress and Egress of Urban Environments}, IEEE transactions on robotics, 2009
	\bibitem{twist} Bret Stanford, Mujahid Abdulrahim, Rick Lind, and Peter Ifju, \textit{Actuation for Roll Control of a Micro Air Vehicle}, Journal of aircraft,  2007
	\bibitem{rev} Juan Carlos Gomez and Ephrahim Garcia, \textit{Morphing unmanned aerial vehicles}, Smart materials and structures, 2011.
	\bibitem{book} E.L. Houghton, P.W. Carpenter, Steven H. Collicott and Daniel T. Valentine, \textit{Aerodynamics for engineering students}, Seventh edition.
	\bibitem{fire} Pero Skorput, Sadko Mandzuka, Hrvoje Vojvodic, \textit{The Use of Unmanned Aerial Vehicles for Forest Fire Monitoring }, 58th International Symposium ELMAR, 2016
	\bibitem{city} David Gallacher, \textit{Drone Applications for Environmental Management in Urban Spaces: A Review}, International Journal of Sustainable Land Use and Urban Planning, 2016
	\bibitem{disaster} Ludovic Apvrille, Tullio Tanzi, and Jean-Luc Dugelay \textit{Autonomous Drones for Assisting Rescue Services within the context of Natural Disasters}, XXXIth URSI General Assembly and Scientific Symposium, 2014
\end{thebibliography}
\bibliographystyle{plainnat}
\listoffigures
\listoftables
\appendix
\section{MAVLink dialect description file}\label{app:mavlink}
\lstinputlisting[language=XML]{../mouse.xml}
\section{Code for STM32 NUCLEO 64 board}
\subsection{Main}
\lstinputlisting[style=CStyle]{../MouseTreadmillSTM32Project/Core/Inc/main.h}
\lstinputlisting[style=CStyle]{../MouseTreadmillSTM32Project/Core/Src/main.c}
\subsection{Treadmill driver}
\lstinputlisting[style=CStyle]{../CodeSTM32/src/mouseDriver.c}
\lstinputlisting[style=CStyle]{../CodeSTM32/src/mouseDriver.h}
\subsection{Sensor driver}
\lstinputlisting[style=CStyle]{../CodeSTM32/src/sensorDriver.c}
\lstinputlisting[style=CStyle]{../CodeSTM32/src/sensorDriver.h}
\subsection{Code for unit tests}
\lstinputlisting[style=CStyle]{../CodeSTM32/test/display.h}
\lstinputlisting[style=CStyle]{../CodeSTM32/test/main.c}
\lstinputlisting[style=CStyle]{../CodeSTM32/test/mock_mouseDriver.h}
\lstinputlisting[style=CStyle]{../CodeSTM32/test/mock_sensorDriver.h}
\lstinputlisting[style=CStyle]{../CodeSTM32/test/test_mouseDriver.h}
\lstinputlisting[style=CStyle]{../CodeSTM32/test/test_sensorDriver.h}
\lstinputlisting[style=CStyle]{../CodeSTM32/test/test_mouseDriver.c}
\lstinputlisting[style=CStyle]{../CodeSTM32/test/test_sensorDriver.c}
\subsection{Build script}
\lstinputlisting[style=CStyle]{../CodeSTM32/src/build.sh}

\section{Code for PC}
\subsection{GUI}
\lstinputlisting[style=PyStyle]{../MouseTreadmillPC/python/mouseController.py}
\subsection{Routine example}
\lstinputlisting[style=PyStyle]{../MouseTreadmillPC/python/routine.py}
\section{Data-sheets}
\subsection{Sensor Data-sheet }\label{app:PMW3660}
\includepdf[pages=-]{../resources/sensorDatasheet.pdf}
%\input{"../docs/latex/refman.tex"}



\end{document}